---
title: "GSE30229"
date: '2018 m. kovas'
output: html_document
---
# Authors
- Edgaras Legus
- Vitalija Misiukonyte
- Brigita Izganaityte
- Gabriele Dilyte
- Dalia Masilionyte
- Reda Vaisetaite
- Paulius Matijosaitis
- Dovile Patiejunaite

# Analysis
## Step 2
Downloading the data using GEO 
```{r, include=TRUE, echo=TRUE}
library(GEOquery)
GSE30229 <- getGEO("GSE30229", destdir = "./")
```

Obtaining the betaValueMatrix of beta values where each row corresponds to probes (names) and each column corresponds to samples

```{r, include=TRUE, echo=TRUE}
betaValueMatrix <- exprs(GSE30229[[1]])
head(rownames(betaValueMatrix))
head(colnames(betaValueMatrix))
```

Counting samples and probes in our data
```{r, include=TRUE, echo=TRUE}
samples <- colnames(betaValueMatrix)
probes <- rownames(betaValueMatrix)
length(samples)
length(probes)
```

Distribution of beta values
```{r, include=TRUE, echo=TRUE}
hist(betaValueMatrix, breaks=1000, xlab = "Beta Value ", border = "green", main = "Beta value distribution")
```

Names of probes
```{r, include=TRUE, echo=TRUE}
head(rownames(betaValueMatrix))
```

Annotation that tells the coordinate (in hg19) of each probe and its genomic features
```{r, include=TRUE, echo=TRUE}
annotate <- getGEO("GPL8490", destdir = "./")
annotate <- Table(annotate)

annotated_probes <- intersect(annotate$ID, rownames(betaValueMatrix))
cat("Probes number: ", length(annotated_probes), "\n")

i <- match(annotated_probes, annotate$ID)
annotate <- annotate[i, ]

i <- match(annotated_probes, rownames(betaValueMatrix))
betaValueMatrix <- betaValueMatrix[i,]
stopifnot(all(rownames(betaValueMatrix) == annotate$ID))

head(annotate)
```

Samples which correspond to healthy individuals, and which samples correspond to the sick ones
```{r, include=TRUE, echo=TRUE}
sickness <- pData(phenoData(GSE30229[[1]]))
sickness[1:20,1]
```

## Step 3

For each probe compute a t-test to verify if the distributions of beta values within the probe significantly differ between the two groups.

```{r, include=TRUE, echo=TRUE}
controlSamples <- which(sickness$`disease:ch1` == 'control')
caseSamples <- which(sickness$`disease:ch1` == 'HNSCC case')
t.test(betaValueMatrix[1,controlSamples], betaValueMatrix[1,caseSamples])
```

From the t-test, obtain the p value.
```{r, include=TRUE, echo=TRUE}
pvalues = c()
for (i in 1:length(rownames(betaValueMatrix))) {
     pvalues[i] <- t.test(betaValueMatrix[i,controlSamples], betaValueMatrix[i,caseSamples])$p.value
     
}
```
Plot the distribution of p values. What is the expected distribution? How dows it differ from what you get?

```{r, include=TRUE, echo=TRUE}
#The peak close to 0 is tall, so there are many p-values close to 0 which means that there is a lot of significant values.
#The "depth" of the histogram on the right side shows the values that are null.
hist(pvalues, col = "green", breaks = 100)
```

Performance-wise, how long will it take to compute the test for all probes?
```{r, include=TRUE, echo=TRUE}
# We used system.time() function to measure the performance. It took 30.100 seconds to perform all the t-tests
```

## Step 4

What is multiple hypothesis testing?
```{r, include=TRUE, echo=TRUE}
#Multiple hypothesis testing occures when we have many different hypotheses and we want to test whether all null hypotheses are true using a single test. Testing them simultaneously increases the chance of getting more "significant" results. #Adjustion for multiple hypothesis testing reduces the chances by increasing the needed "significance".
```

How should we adjust for multiple hypothesis testing in our case?
```{r, include=TRUE, echo=TRUE}
pvalues.adjusted <- p.adjust(pvalues, method="BH", n = length(pvalues))
#For adjustion we chose "BH" method because it controls the proportion of false discovery which is expected among the rejected hypotheses.
```

Did you find any probes that show statistically significant modification difference between healthy and sick individuals?
```{r, include=TRUE, echo=TRUE}
probes.significant <- probes[pvalues.adjusted < 0.05]
probes.significant[1:20]
#We choose that the adjusted p-value is "significant" if its value is below 0.05.
```

Where are these probes? What genes are they related to?
```{r, include=TRUE, echo=TRUE}
annotate$Gene_ID[match(probes.significant, annotate$ID)][1:20]
annotate$CPG_ISLAND_LOCATIONS[match(probes.significant, annotate$ID)][1:20]
#We find what genes the probes are related to and what chromosomes they are located at.
```

## Next steps

Normalizavimas
```{r, include=TRUE, echo=TRUE}
#Normalizuojame beta verciu matrica deka normalizeBetweenArrays metodo.
library("limma")
normalizedMatrix <- normalizeBetweenArrays(betaValueMatrix)
```

Gauti rezultatai is https://dnamage.genetics.ucla.edu
```{r, include=TRUE, echo=TRUE}
#Pasileidziame gauta csv faila ir extractiname reikalingus stulpelius, kuriuos pridedame prie sickness
researchColumns <- read.csv('GSE30229.csv')
age_and_gender <- researchColumns[,c("DNAmAge","predictedGender")]
age_gender_matrix <- data.matrix(age_and_gender)
age_gender_matrix[which(age_gender_matrix[,2] == 2),2] <- "male"
age_gender_matrix
age_gender_matrix[which(age_gender_matrix[,2] == 1),2] <- "female"
age_gender_matrix
full_sickness <- cbind(sickness, age_gender_matrix)
```

Lytiniu chromosomu probu atmetimas
```{r, include=TRUE, echo=TRUE}
#Gauname X ir Y chromosomu indeksus anotacijos faile tam kad juos pasalinti. 
#Taip pat pasaliname lytines chromosomas ir normalizuotoje matricoje.
X_and_Y_indexes <- which(annotate$Chr == 'X' | annotate$Chr == 'Y')
annotate_without_genderCh <- annotate[-(X_and_Y_indexes),]
normalizedMatrix_without_genderCh <- normalizedMatrix[-(X_and_Y_indexes),]
```

PCA
```{r, include=TRUE, echo=TRUE}
library("impute")

#Palyginame kaip atrodys grafikas su nepasalintomis lytinemis chromosomomis ir 
#kaip atrodys grafikas su jau pasalintomis lytinemis chromosomomis. 
x <- 1:10

imputed_1 <- impute.knn(normalizedMatrix)
pca_1 <- prcomp(t(imputed_1$data), scale=FALSE)
pairs(pca_1$x[,1:4], col=as.factor(full_sickness$predictedGender))

imputed_2 <- impute.knn(normalizedMatrix_without_genderCh)
pca_2 <- prcomp(t(imputed_2$data), scale=FALSE)
pairs(pca_2$x[,1:4], col=as.factor(full_sickness$predictedGender))
```
Outliers
```{r, include=TRUE, echo=TRUE}
#Dar karta pavaizduojame grafika be lytiniu chromosomu
normalizedMatrix_without_genderCh <- impute.knn(normalizedMatrix_without_genderCh)$data
pca_first <- prcomp(t(normalizedMatrix_without_genderCh))
pairs(pca_2$x[,1:4], col=as.factor(full_sickness$predictedGender))

#Identifikuojame outliers po pairs grafiko analizes, taikome PC1 ir PC2 dalims, vyksta pimrasis outlieriu salinimas
out1 <- which(abs(pca_first$x[,1]) > 3*sd(abs(pca_first$x[,1])))
out2 <- which(abs(pca_first$x[,2]) > 3*sd(abs(pca_first$x[,2])))
outs <- unique(c(out1, out2))
outs


#Ismetame meginius, karpome eilutes is full_sickness ir stulpelius is normalizedMatrix_without_genderCh
normalizedMatrix_without_1stoutliers <- normalizedMatrix_without_genderCh[,-c(outs)]
full_sickness_without_1stoutliers <- full_sickness[-(outs),]

#Pavaizduojame grafika be outlieriu
pairs(pca_first$x[-outs,1:4])


#Dabar darom antra outlieriu salinima, pritaikom PC1, PC2, PC3, PC4 dalims.
pca_second <- prcomp(t(normalizedMatrix_without_1stoutliers))
out1 <- which(abs(pca_second$x[,1]) > 3*sd(abs(pca_second$x[,1])))
out2 <- which(abs(pca_second$x[,2]) > 3*sd(abs(pca_second$x[,2])))
out3 <- which(abs(pca_second$x[,3]) > 3*sd(abs(pca_second$x[,3])))
out4 <- which(abs(pca_second$x[,4]) > 3*sd(abs(pca_second$x[,4])))
second_outs <- unique(c(out1, out2, out3, out4))
second_outs

normalizedMatrix_without_outliers <- normalizedMatrix_without_1stoutliers[,-c(second_outs)]
full_sickness_without_outliers <- full_sickness_without_1stoutliers[-(second_outs),]

#Pavaizduojame isvalytus duomenis, be outlieriu ir be lytiniu chromosomu
pairs(pca_second$x[-second_outs,1:4])
```

Permutations
```{r, include=TRUE, echo=TRUE}
set.seed(123)
groups <- sample(0:1, ncol(normalizedMatrix_without_outliers), replace = TRUE)
expected <- numeric(100)
for (iteration in 1:10) {
  groupsRandom <- sample(groups)
  pvalsRandom <- apply(normalizedMatrix_without_outliers[1:1000,],1, function(normalized_matrix_without_outliers) {lmFit(normalized_matrix_without_outliers, groupsRandom)$P.Value})
  expected[iteration] <- mean(pvalsRandom < 0.05)
  print(pvalsRandom)
}
```
Final analysis
```{r, include=TRUE, echo=TRUE}
library(limma)
age <- rnorm(ncol(normalizedMatrix_without_outliers), mean=60)
model <- model.matrix(~ 1 + groups)
fit <- lmFit(normalizedMatrix_without_outliers, model)
fit <- eBayes(fit)
topTable(fit, coef=2)
```